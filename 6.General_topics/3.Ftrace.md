# Ftrace

trace is built around smart lockless ring buffer implementation.

nabled in most distros by default

Activated by Kernel Hacking -> Tracers

Minimum kernel configuration required for ftraces
-------------------------------------------------
- CONFIG_FTRACE --> "Tracers"
- CONFIG_FUNCTION_TRACER --> Kernel Function Tracer
- CONFIG_FUNCTION_GRAPH_TRACER --> Kernel Function Graph Tracer
- CONFIG_STACK_TRACER	--> Traces Max stack

How to check whether ftrace is already enabled or not?
------------------------------------------------------

Most of the Linux distributions already provide ftrace, to check verify "tracing" directory exists or not.
```c++
# cat /boot/config-'uname-r' | grep CONFIG_FUNCTION_GRAPH_TRACER

# ls /sys/kernel/tracing
```
mount the tracefs by any of the two steps:

1. Adding an entry into /etc/fstab:
```C++
 tracefs       /sys/kernel/tracing       tracefs defaults        0       0
```
2. Using the mount command:
```C++
# umount /sys/kernel/tracing   
#mount -t tracefs nodev /sys/kernel/tracing
```
After mounting tracefs, you will have access to the control and output files of ftrace.

It was initially in debugfs(`/sys/kernel/debug/tracing`)

available_tracers
=================

Lists which tracers are configured

Important ones are:

	nop	 	-	No Action (No Tracer Enabled)
	function 	-	Trace Kernel Functions Entry
	function_graph	-	Trace Kernel Functions Entry and Exit  thus allowing to build a call graph
	blk		-	Block Tracer/blktrace
	mmiotrace	-	Trace interactions between drivers and hardware

Default tracer is nop

current_tracer
===============

The tracing program presently running

------------------------------------------------------

How to enable a tracer?
------------------------
```bash
$ echo 'name of tracer' > current_tracer 

$ echo 'function' > current_tracer

$ echo 'function_graph' > current_tracer

$ echo 'nop' > current_tracer
```
![image](https://github.com/user-attachments/assets/88349aa0-df23-4edf-a27b-6d762795d171)
