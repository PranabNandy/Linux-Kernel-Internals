## Tasklets


Tasklets are bottom half mechanism built on top of softirqs.

Handlers of tasklets are executed by softirqs

Implementation
----------------

Tasklets are implemented on top of softirqs.

Tasklets are represented by two softirqs: HI_SOFTIRQ and TASKLET_SOFTIRQ.

The only difference in these types is that the HI_SOFTIRQ-based tasklets run prior to the TASKLET_SOFTIRQ based
tasklets.


Data Structure
----------------

```c++
tasklet_struct
Header File: <linux/interrupt.h>

struct tasklet_struct
{
        struct tasklet_struct *next; /* next tasklet in the list */
        unsigned long state;   /* state of the tasklet */
        atomic_t count;		/* reference counter */
        void (*func)(unsigned long); /* tasklet handler function */
        unsigned long data;  /* argument to the tasklet function */
};
```

state field
-------------

It can be 
-	a) TASKLET_STATE_SCHED
-	b) TASKLET_STATE_RUN
--------------
- TASKLET_STATE_SCHED denotes a tasklet that is scheduled to run
- TASKLET_STATE_RUN denotes a tasklet that is running

TASKLET_STATE_RUN is used only on multiprocessor machines.

It is used to protect tasklets against concurrent execution on several processors.

count field
------------

used as a reference count for the tasklet
- count = 0 	===>	the tasklet is enabled and can run if marked pending
- count = nonzero  ==>		the tasklet is disabled and cannot run


Declaring Tasklets
===================

Static Initialization
----------------------

DECLARE_TASKLET
```
	#define DECLARE_TASKLET(name, func, data) \
	struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data }
```
DECLARE_TASKLET_DISABLED
```
	#define DECLARE_TASKLET_DISABLED(name, func, data) \
	struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(1), func, data }
```
Both these macros statically create a struct tasklet_struct with the given name.
When the tasklet is scheduled, the given function func is executed and passed data as argument.

The difference between the two macros is the initial reference count.

Dynamic
--------
```c++
void tasklet_init(struct tasklet_struct *t,
                         void (*func)(unsigned long), unsigned long data);
```

## Example of tasklet
```c++
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");
char tasklet_data[] = "linux kernel is very easy";

void tasklet_function(unsigned long data)
{
	pr_info("%s:data:%s\n", __func__, (char *)data);
	return;
}


DECLARE_TASKLET(my_tasklet, tasklet_function, (unsigned long)&tasklet_data);
DECLARE_TASKLET_DISABLED(my_tasklet_disabled, tasklet_function, (unsigned long)&tasklet_data);


static int test_tasklet_init(void)
{
        pr_info("%s: In init\n", __func__);
	pr_info("State:%ld\n", my_tasklet.state);  // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet.count));  // 0 for enabled tasklet
	pr_info("State:%ld\n", my_tasklet_disabled.state);  // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet_disabled.count)); // 1 for disabled tasklet
	return 0;
}

static void test_tasklet_exit(void)
{
        pr_info("%s: In exit\n", __func__);
}

module_init(test_tasklet_init);
module_exit(test_tasklet_exit);
```



Scheduling Tasklets
--------------------

The kernel maintains two per-CPU tasklet linked lists for queuing scheduled tasklets
```c++
kernel/softirq.c

static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);
static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);

tasklet_vec : for regular tasklets, run by TASKLET_SOFTIRQ and 
tasklet_hi_vec : for high-priority tasklets, run by HI_SOFTIRQ

Both of these structures are linked lists of tasklet_struct structures.

Each tasklet_struct structure in the list represents a different tasklet.

struct tasklet_head {
        struct tasklet_struct *head;
        struct tasklet_struct **tail;
};
```
Tasklets are scheduled via the tasklet_schedule() and tasklet_hi_schedule()
```c++
static inline void tasklet_schedule(struct tasklet_struct *t)
{
        if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
                __tasklet_schedule(t);
}
```
- The above function checks whether the tasklet is already scheduled, if not it atomically sets the state to
- TASKLET_STATE_SCHED and invokes __tasklet_schedule to add the tasklet into the pending queue.


## Dynamic Initialization of Tasklet

```c++
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/slab.h>
MODULE_LICENSE("GPL");
char tasklet_data[] = "linux kernel is very easy";

void tasklet_function(unsigned long data)
{
	pr_info("%s:data:%s\n", __func__, (char *)data);
	return;
}


static struct tasklet_struct *my_tasklet;
static int test_tasklet_init(void)
{
        pr_info("%s: In init\n", __func__);
	my_tasklet = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
	pr_info("State:%ld\n", my_tasklet->state);               // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet->count));  // 0
	tasklet_init(my_tasklet, tasklet_function, tasklet_data);
	pr_info("State:%ld\n", my_tasklet->state);               // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet->count));  // 0
	tasklet_schedule(my_tasklet);	
	pr_info("State:%ld\n", my_tasklet->state);               // 1
	pr_info("Count:%d\n", atomic_read(&my_tasklet->count));  // 0
	return 0;
}

static void test_tasklet_exit(void)
{
        pr_info("%s: In exit\n", __func__);
	kfree(my_tasklet);
}

module_init(test_tasklet_init);
module_exit(test_tasklet_exit);
```


Steps performed by tasklet_schedule
------------------------------------

1. Check whether the taskletâ€™s state is TASKLET_STATE_SCHED.
	If it is, the tasklet is already scheduled to run and the function can immediately return.

2. Call __tasklet_schedule()

3. Save the state of the interrupt system, and then disable local interrupts by calling local_irq_save
	This ensures that nothing on this processor will mess with the tasklet code while tasklet_schedule() is manipulating the tasklets

4. Add the tasklet to be scheduled to the head of the tasklet_vec or tasklet_hi_vec linked list, which is unique to each processor in the system
	 
5. Raise the TASKLET_SOFTIRQ or HI_SOFTIRQ softirq, so do_softirq() executes this tasklet in the near future

6. Restore interrupts to their previous state and return


```c++
static void __tasklet_schedule_common(struct tasklet_struct *t,
                                      struct tasklet_head __percpu *headp,
                                      unsigned int softirq_nr)
{
        struct tasklet_head *head;
        unsigned long flags;

        local_irq_save(flags);
        head = this_cpu_ptr(headp);
        t->next = NULL;
        *head->tail = t;
        head->tail = &(t->next);
        raise_softirq_irqoff(softirq_nr);
        local_irq_restore(flags);
}
```
