## Tasklets


Tasklets are bottom half mechanism built on top of softirqs.

Handlers of tasklets are executed by softirqs

Implementation
----------------

Tasklets are implemented on top of softirqs.

Tasklets are represented by two softirqs: HI_SOFTIRQ and TASKLET_SOFTIRQ.

The only difference in these types is that the HI_SOFTIRQ-based tasklets run prior to the TASKLET_SOFTIRQ based
tasklets.


Data Structure
----------------

```c++
tasklet_struct
Header File: <linux/interrupt.h>

struct tasklet_struct
{
        struct tasklet_struct *next; /* next tasklet in the list */
        unsigned long state;   /* state of the tasklet */
        atomic_t count;		/* reference counter */
        void (*func)(unsigned long); /* tasklet handler function */
        unsigned long data;  /* argument to the tasklet function */
};
```

state field
-------------

It can be 
-	a) TASKLET_STATE_SCHED
-	b) TASKLET_STATE_RUN
--------------
- TASKLET_STATE_SCHED denotes a tasklet that is scheduled to run
- TASKLET_STATE_RUN denotes a tasklet that is running

TASKLET_STATE_RUN is used only on multiprocessor machines.

It is used to protect tasklets against concurrent execution on several processors.

count field
------------

used as a reference count for the tasklet
- count = 0 	===>	the tasklet is enabled and can run if marked pending
- count = nonzero  ==>		the tasklet is disabled and cannot run


Declaring Tasklets
===================

Static Initialization
----------------------

DECLARE_TASKLET
```
	#define DECLARE_TASKLET(name, func, data) \
	struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data }
```
DECLARE_TASKLET_DISABLED
```
	#define DECLARE_TASKLET_DISABLED(name, func, data) \
	struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(1), func, data }
```
Both these macros statically create a struct tasklet_struct with the given name.
When the tasklet is scheduled, the given function func is executed and passed data as argument.

The difference between the two macros is the initial reference count.

Dynamic
--------
```c++
void tasklet_init(struct tasklet_struct *t,
                         void (*func)(unsigned long), unsigned long data);
```

## Example of tasklet
```c++
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");
char tasklet_data[] = "linux kernel is very easy";

void tasklet_function(unsigned long data)
{
	pr_info("%s:data:%s\n", __func__, (char *)data);
	return;
}


DECLARE_TASKLET(my_tasklet, tasklet_function, (unsigned long)&tasklet_data);
DECLARE_TASKLET_DISABLED(my_tasklet_disabled, tasklet_function, (unsigned long)&tasklet_data);


static int test_tasklet_init(void)
{
        pr_info("%s: In init\n", __func__);
	pr_info("State:%ld\n", my_tasklet.state);  // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet.count));  // 0 for enabled tasklet
	pr_info("State:%ld\n", my_tasklet_disabled.state);  // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet_disabled.count)); // 1 for disabled tasklet
	return 0;
}

static void test_tasklet_exit(void)
{
        pr_info("%s: In exit\n", __func__);
}

module_init(test_tasklet_init);
module_exit(test_tasklet_exit);
```



Scheduling Tasklets
--------------------

The kernel maintains two per-CPU tasklet linked lists for queuing scheduled tasklets
```c++
kernel/softirq.c

static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);
static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);

tasklet_vec : for regular tasklets, run by TASKLET_SOFTIRQ and 
tasklet_hi_vec : for high-priority tasklets, run by HI_SOFTIRQ

Both of these structures are linked lists of tasklet_struct structures.

Each tasklet_struct structure in the list represents a different tasklet.

struct tasklet_head {
        struct tasklet_struct *head;
        struct tasklet_struct **tail;
};
```
Tasklets are scheduled via the tasklet_schedule() and tasklet_hi_schedule()
```c++
static inline void tasklet_schedule(struct tasklet_struct *t)
{
        if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
                __tasklet_schedule(t);
}
```
- The above function checks whether the tasklet is already scheduled, if not it atomically sets the state to
- TASKLET_STATE_SCHED and invokes __tasklet_schedule to add the tasklet into the pending queue.


## Dynamic Initialization of Tasklet

```c++
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/slab.h>
MODULE_LICENSE("GPL");
char tasklet_data[] = "linux kernel is very easy";

void tasklet_function(unsigned long data)
{
	pr_info("%s:data:%s\n", __func__, (char *)data);
	return;
}


static struct tasklet_struct *my_tasklet;
static int test_tasklet_init(void)
{
        pr_info("%s: In init\n", __func__);
	my_tasklet = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
	pr_info("State:%ld\n", my_tasklet->state);               // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet->count));  // 0
	tasklet_init(my_tasklet, tasklet_function, tasklet_data);
	pr_info("State:%ld\n", my_tasklet->state);               // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet->count));  // 0
	tasklet_schedule(my_tasklet);	
	pr_info("State:%ld\n", my_tasklet->state);               // 1
	pr_info("Count:%d\n", atomic_read(&my_tasklet->count));  // 0
	return 0;
}

static void test_tasklet_exit(void)
{
        pr_info("%s: In exit\n", __func__);
	kfree(my_tasklet);
}

module_init(test_tasklet_init);
module_exit(test_tasklet_exit);
```


Steps performed by tasklet_schedule
------------------------------------

1. Check whether the taskletâ€™s state is TASKLET_STATE_SCHED.
	If it is, the tasklet is already scheduled to run and the function can immediately return.

2. Call __tasklet_schedule()

3. Save the state of the interrupt system, and then disable local interrupts by calling local_irq_save
	This ensures that nothing on this processor will mess with the tasklet code while tasklet_schedule() is manipulating the tasklets

4. Add the tasklet to be scheduled to the head of the tasklet_vec or tasklet_hi_vec linked list, which is unique to each processor in the system
	 
5. Raise the TASKLET_SOFTIRQ or HI_SOFTIRQ softirq, so do_softirq() executes this tasklet in the near future

6. Restore interrupts to their previous state and return


```c++
static void __tasklet_schedule_common(struct tasklet_struct *t,
                                      struct tasklet_head __percpu *headp,
                                      unsigned int softirq_nr)
{
        struct tasklet_head *head;
        unsigned long flags;

        local_irq_save(flags);
        head = this_cpu_ptr(headp);
        t->next = NULL;
        *head->tail = t;
        head->tail = &(t->next);
        raise_softirq_irqoff(softirq_nr);
        local_irq_restore(flags);
}
```


Steps performed by tasklet softirq handlers
--------------------------------------------

Handlers: tasklet_action()/tasklet_hi_action()

1. Disable local interrupt delivery and get the tasklet_vec or tasklet_hi_vec list for this processor

2. Clear the list for this processor by setting it equal to NULL.

3. Enable local interrupt delivery.
```
        struct tasklet_struct *list;

        local_irq_disable();
        list = tl_head->head;
        tl_head->head = NULL;
        tl_head->tail = &tl_head->head;
        local_irq_enable();
```
4. Loop over each pending tasklet in the retrieved list.

5. Check for a zero count value, to ensure the tasklet is not disabled. If the tasklet is disabled, skip it and go to the next pending tasklet.

6. Run the tasklet handler.

7. Repeat the next pending tasklet, until there are no more scheduled tasklets waiting to run.
   


How kernel avoids running the same tasklet on multiple processors
------------------------------------------------------------------

- tasklet_trylock

- tasklet_unlock
```
static inline int tasklet_trylock(struct tasklet_struct *t)
{
        return !test_and_set_bit(TASKLET_STATE_RUN, &(t)->state);
}

static inline void tasklet_unlock(struct tasklet_struct *t)
{
        smp_mb__before_atomic();
        clear_bit(TASKLET_STATE_RUN, &(t)->state);
}
```
On a multiprocessor machine, the kernel checks whether TASKLET_STATE_RUN is set (which means another processor is running this tasklet).

-	If set, do not execute now and skip to the next pending tasklet
-	Else set the TASKLET_STATE_RUN flag so that another processor cannot execute
-	After the tasklet completes, clear the TASKLET_STATE_RUN flag


Can i sleep in tasklet handler?
--------------------------------

As tasklets are based on softirqs, you cannot sleep.

You cannot use semaphores or other blocking functions in tasklet handler


### Are interrupt enabled when tasklet run

- Yes
- Tasklet can be preempted by interrupt handler
- Tasklet is running in **Interrupt context**
- Tasklet is running by ksoftirqd/cpu_id
- Tasklet is running in Soft Irq context

What happens if i call tasklet_schedule twice?
------------------------------------------------

After a tasklet is scheduled, it runs once at some time in the near future. If the same tasklet is scheduled again, before it has had a chance to run, it still runs only once

### Why tasklet executed before softirq 
- Even though both are calling from same bottom_handler
<img width="1192" height="466" alt="image" src="https://github.com/user-attachments/assets/ba783c3c-7d7f-4597-86b7-3bcf5a354247" />

Enabling/Disabling Tasklets
------------------------------

Disable tasklet
-	tasklet_disable()
-	tasklet_disable_nosync()

Enable tasklet
-	tasklet_enable()

`tasklet_disable()` will wait if the tasklet is currently running and return only after it has finished execution

`tasklet_disable_nosync()` will not wait for the tasklet to complete prior to returning

```
static inline void tasklet_disable_nosync(struct tasklet_struct *t)
{
        atomic_inc(&t->count);
        smp_mb__after_atomic();
}

static inline void tasklet_disable(struct tasklet_struct *t)
{
        tasklet_disable_nosync(t);
        tasklet_unlock_wait(t);
        smp_mb();
}

static inline void tasklet_enable(struct tasklet_struct *t)
{
        smp_mb__before_atomic();
        atomic_dec(&t->count);
}
```

```c++
#include <linux/module.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/delay.h>
#include <linux/slab.h>

#define SHARED_IRQ 19   // Interrupt for ethernet
static int irq = SHARED_IRQ, my_dev_id, irq_counter = 0;
module_param(irq, int, S_IRUGO);

static struct tasklet_struct *my_tasklet;
static irqreturn_t my_interrupt(int irq, void *dev_id)
{
	irq_counter++;
	pr_info("In the ISR: counter = %d\n", irq_counter);
	tasklet_schedule(my_tasklet);
	return IRQ_NONE;	/* we return IRQ_NONE because we are just observing */
}

void tasklet_function(unsigned long data)
{
	pr_info("starting tasklet function\n");
	mdelay(10000);
	pr_info("ending tasklet function\n");
        return;
}


static int __init my_init(void)
{
	my_tasklet = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
	tasklet_init(my_tasklet, tasklet_function, NULL);

	if (request_irq
	    (irq, my_interrupt, IRQF_SHARED, "my_interrupt", &my_dev_id)) {
		pr_info("Failed to reserve irq %d\n", irq);
		return -1;
	}
	pr_info("Successfully loading ISR handler\n");
	return 0;
}

static void __exit my_exit(void)
{
	synchronize_irq(irq);
	free_irq(irq, &my_dev_id);
	tasklet_disable(my_tasklet);
	kfree(my_tasklet);
	pr_info("Successfully unloading,  irq_counter = %d\n", irq_counter);
}

MODULE_LICENSE("GPL");
module_init(my_init);
module_exit(my_exit);
```


tasklet_kill
----------------

void tasklet_kill(struct tasklet_struct *t);

The function removes a tasklet from the pending queue.
```c++
void tasklet_kill(struct tasklet_struct *t)
{
        if (in_interrupt())
                pr_notice("Attempt to kill tasklet from interrupt\n");

        while (test_and_set_bit(TASKLET_STATE_SCHED, &t->state)) {
                do {
                        yield();
                } while (test_bit(TASKLET_STATE_SCHED, &t->state));
        }
        tasklet_unlock_wait(t);
        clear_bit(TASKLET_STATE_SCHED, &t->state);
}
```
This function **must not be used from interrupt context** because it sleeps

If the tasklet specified is already scheduled by the time this call is invoked, then this function waits until its execution completes.

```c++
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");


char tasklet_data[] = "linux kernel is very easy";
void tasklet_function(unsigned long data);

DECLARE_TASKLET(my_tasklet, tasklet_function, (unsigned long)&tasklet_data);

void tasklet_function(unsigned long data)
{
	pr_info("starting tasklet function\n");
	mdelay(4000);
	pr_info("ending tasklet function\n");
	return;
}

static int test_tasklet_init(void)
{
        pr_info("%s: In init\n", __func__);
	pr_info("State:%ld\n", my_tasklet.state);
	pr_info("Count:%d\n", atomic_read(&my_tasklet.count));
	tasklet_schedule(&my_tasklet);	
	pr_info("State:%ld\n", my_tasklet.state);
	pr_info("Count:%d\n", atomic_read(&my_tasklet.count));
	pr_info("killing tasklet\n");
	tasklet_kill(&my_tasklet);
	pr_info("State:%ld\n", my_tasklet.state);
	pr_info("Count:%d\n", atomic_read(&my_tasklet.count));
	return 0;
}

static void test_tasklet_exit(void)
{
        pr_info("%s: In exit\n", __func__);
}

module_init(test_tasklet_init);
module_exit(test_tasklet_exit);
```


tasklet_hi_schedule
------------------------

In addition to normal tasklets, the kernel uses a second kind of tasklet of a higher priority.

HI_SOFTIRQ is used as a softIRQ instead of TASKLET_SOFTIRQ

tasklet_hi_schedule() should be used if the tasklet should  run more urgently than networking, SCSI, timers 

```c++
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");


char tasklet_data[] = "linux kernel is very easy";

void tasklet1_function(unsigned long data)
{
	pr_info("TASKLET_SOFTIRQ start\n");
	pr_info("TASKLET_SOFTIRQ end\n");
	return;
}

void tasklet2_function(unsigned long data)
{
	pr_info("HI_SOFTIRQ start\n");
	pr_info("HI_SOFTIRQ end\n");
	return;
}

DECLARE_TASKLET(my_tasklet1, tasklet1_function, (unsigned long)&tasklet_data);
DECLARE_TASKLET(my_tasklet2, tasklet2_function, (unsigned long)&tasklet_data);

static int test_tasklet_init(void)
{
        pr_info("%s: In init\n", __func__);
	tasklet_schedule(&my_tasklet1);	
	tasklet_hi_schedule(&my_tasklet2);
	return 0;
}

static void test_tasklet_exit(void)
{
        pr_info("%s: In exit\n", __func__);
}

module_init(test_tasklet_init);
module_exit(test_tasklet_exit);
```


### Disabling the tasklet using tasklet_bh_disable
```c++
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");


char tasklet_data[] = "linux kernel is very easy";
void tasklet_function(unsigned long data);

DECLARE_TASKLET(my_tasklet, tasklet_function, (unsigned long)&tasklet_data);

void tasklet_function(unsigned long data)
{
	pr_info("starting tasklet function\n");
	mdelay(4000);
	pr_info("ending tasklet function\n");
	return;
}

static int test_tasklet_init(void)
{
        pr_info("%s: In init\n", __func__);
	tasklet_schedule(&my_tasklet);	
	pr_info("disabling bottom halves\n");
	local_bh_disable();
	mdelay(5000);
	pr_info("bottom halves enabled\n");
	local_bh_enable();
	return 0;
}

static void test_tasklet_exit(void)
{
        pr_info("%s: In exit\n", __func__);
}

module_init(test_tasklet_init);
module_exit(test_tasklet_exit);
```


Softirqs vs tasklets
----------------------
```
			     Softirqs			             Tasklets	
		
Allocation:		Allocated at compile time	     Can be dynamically registered

Reentrancy:		Yes, same softirqs can run	     No, Same tasklet will not be scheduled
			    on different processors		     on different processors

```

	


