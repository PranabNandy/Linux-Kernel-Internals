## Tasklets


Tasklets are bottom half mechanism built on top of softirqs.

Handlers of tasklets are executed by softirqs

Implementation
----------------

Tasklets are implemented on top of softirqs.

Tasklets are represented by two softirqs: HI_SOFTIRQ and TASKLET_SOFTIRQ.

The only difference in these types is that the HI_SOFTIRQ-based tasklets run prior to the TASKLET_SOFTIRQ based
tasklets.


Data Structure
----------------

```c++
tasklet_struct
Header File: <linux/interrupt.h>

struct tasklet_struct
{
        struct tasklet_struct *next; /* next tasklet in the list */
        unsigned long state;   /* state of the tasklet */
        atomic_t count;		/* reference counter */
        void (*func)(unsigned long); /* tasklet handler function */
        unsigned long data;  /* argument to the tasklet function */
};
```

state field
-------------

It can be 
-	a) TASKLET_STATE_SCHED
-	b) TASKLET_STATE_RUN
--------------
- TASKLET_STATE_SCHED denotes a tasklet that is scheduled to run
- TASKLET_STATE_RUN denotes a tasklet that is running

TASKLET_STATE_RUN is used only on multiprocessor machines.

It is used to protect tasklets against concurrent execution on several processors.

count field
------------

used as a reference count for the tasklet
- count = 0 	===>	the tasklet is enabled and can run if marked pending
- count = nonzero  ==>		the tasklet is disabled and cannot run


Declaring Tasklets
===================

Static Initialization
----------------------

DECLARE_TASKLET
```
	#define DECLARE_TASKLET(name, func, data) \
	struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data }
```
DECLARE_TASKLET_DISABLED
```
	#define DECLARE_TASKLET_DISABLED(name, func, data) \
	struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(1), func, data }
```
Both these macros statically create a struct tasklet_struct with the given name.
When the tasklet is scheduled, the given function func is executed and passed data as argument.

The difference between the two macros is the initial reference count.

Dynamic
--------
```c++
void tasklet_init(struct tasklet_struct *t,
                         void (*func)(unsigned long), unsigned long data);
```

## Example of tasklet
```c++
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");
char tasklet_data[] = "linux kernel is very easy";

void tasklet_function(unsigned long data)
{
	pr_info("%s:data:%s\n", __func__, (char *)data);
	return;
}


DECLARE_TASKLET(my_tasklet, tasklet_function, (unsigned long)&tasklet_data);
DECLARE_TASKLET_DISABLED(my_tasklet_disabled, tasklet_function, (unsigned long)&tasklet_data);


static int test_tasklet_init(void)
{
        pr_info("%s: In init\n", __func__);
	pr_info("State:%ld\n", my_tasklet.state);  // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet.count));  // 0 for enabled tasklet
	pr_info("State:%ld\n", my_tasklet_disabled.state);  // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet_disabled.count)); // 1 for disabled tasklet
	return 0;
}

static void test_tasklet_exit(void)
{
        pr_info("%s: In exit\n", __func__);
}

module_init(test_tasklet_init);
module_exit(test_tasklet_exit);
```



Scheduling Tasklets
--------------------

The kernel maintains two per-CPU tasklet linked lists for queuing scheduled tasklets
```c++
kernel/softirq.c

static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);
static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);

tasklet_vec : for regular tasklets, run by TASKLET_SOFTIRQ and 
tasklet_hi_vec : for high-priority tasklets, run by HI_SOFTIRQ

Both of these structures are linked lists of tasklet_struct structures.

Each tasklet_struct structure in the list represents a different tasklet.

struct tasklet_head {
        struct tasklet_struct *head;
        struct tasklet_struct **tail;
};
```
Tasklets are scheduled via the tasklet_schedule() and tasklet_hi_schedule()
```c++
static inline void tasklet_schedule(struct tasklet_struct *t)
{
        if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
                __tasklet_schedule(t);
}
```
- The above function checks whether the tasklet is already scheduled, if not it atomically sets the state to
- TASKLET_STATE_SCHED and invokes __tasklet_schedule to add the tasklet into the pending queue.


## Dynamic Initialization of Tasklet

```c++
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/slab.h>
MODULE_LICENSE("GPL");
char tasklet_data[] = "linux kernel is very easy";

void tasklet_function(unsigned long data)
{
	pr_info("%s:data:%s\n", __func__, (char *)data);
	return;
}


static struct tasklet_struct *my_tasklet;
static int test_tasklet_init(void)
{
        pr_info("%s: In init\n", __func__);
	my_tasklet = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
	pr_info("State:%ld\n", my_tasklet->state);               // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet->count));  // 0
	tasklet_init(my_tasklet, tasklet_function, tasklet_data);
	pr_info("State:%ld\n", my_tasklet->state);               // 0
	pr_info("Count:%d\n", atomic_read(&my_tasklet->count));  // 0
	tasklet_schedule(my_tasklet);	
	pr_info("State:%ld\n", my_tasklet->state);               // 1
	pr_info("Count:%d\n", atomic_read(&my_tasklet->count));  // 0
	return 0;
}

static void test_tasklet_exit(void)
{
        pr_info("%s: In exit\n", __func__);
	kfree(my_tasklet);
}

module_init(test_tasklet_init);
module_exit(test_tasklet_exit);
```


